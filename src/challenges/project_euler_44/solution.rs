use std::ops::{Add, Sub};
use std::time::Instant;
use std::collections::BTreeSet;

///
/// Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
//
// 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
//
// It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
//
// Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| is minimised; what is the value of D?
///

pub fn calculate() {
    let start = Instant::now();
    let mut answer = 0;

    answer = find_answer();

    println!("Project Euler 44: {}, Time Taken: {}", answer, start.elapsed().as_millis());
}

pub fn find_answer() -> i32 {
    // n*(3n - 1)/2 = (3n^2 - n)/2
    // Which has big O(n^2)
    // Therefore, the difference will be growing faster than n
    // So we can brute force by looking at each new sequence value and checking if it's the sum
    // The first one we find which can be a sum will also be the answer

    let mut n = 4;
    let mut previous = BTreeSet::from([1, 5, 12]);

    loop {
        let new_value = pentagonal(n);

        for larger in previous.iter() {
            let smaller = new_value - larger;

            // If the smaller number isn't in the sequence continue
            if !previous.contains(&smaller) {
                continue;
            }

            let difference = larger - smaller;

            // If the difference is in the sequence
            // Then it must be the smallest possible value
            if previous.contains(&difference) {
                return difference;
            }
        }


        previous.insert(new_value);
        n += 1;
    }
}

fn pentagonal(n: i32) -> i32 {
    n*(3*n - 1)/2
}